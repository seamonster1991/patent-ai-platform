# 핵심 결제 시스템 구축 PRD (PG사 연동 준비)

## 1. 프로젝트 목표 및 유의 사항

### 목표
정기 결제, 추가 충전, 소멸 기한이 복합적으로 적용되는 포인트 기반의 결제 시스템 구축. 안정적인 현금 흐름과 사용자 행동 유도에 최적화.

### PG사 연동 준비
- 현재 **PG사(Payment Gateway)**는 결정되지 않았으므로, 모든 결제 확인(Payment Confirmation) 로직은 Stripe Webhook 또는 가상의 결제 완료 신호를 수신하는 형태로 선행 설계
- PG사 관련 API 연동은 추후 보완 예정

### 핵심 원칙
포인트 차감은 가장 소멸 기한이 임박한 포인트부터 사용하는 **FEFO(First-Expired, First-Out)** 방식을 엄격하게 적용

## 2. 데이터베이스 구조 (Supabase Schemas)

### 목표
포인트의 출처, 소멸 기한, 잔액을 투명하고 정확하게 관리

### 2.1. user_point_balances 테이블

| 필드명 | 데이터 타입 | 설명 |
|--------|-------------|------|
| user_id | uuid | Supabase Auth의 사용자 ID (FK) |
| current_balance | int | 현재 사용 가능한 총 포인트 잔액 (대시보드 표시용) |
| last_updated | timestampz | 최종 잔액 업데이트 시간 |

### 2.2. point_transactions 테이블 (핵심: 소멸 기한 추적)

| 필드명 | 데이터 타입 | 설명 |
|--------|-------------|------|
| id | uuid | 거래 ID (PK) |
| user_id | uuid | 사용자 ID (FK) |
| type | text | 거래 유형 (charge_monthly, charge_addon, bonus, usage, expiration) |
| amount | int | 거래 포인트 금액 (충전은 +, 차감/소멸은 -) |
| source_amount_krw | int | 결제된 원화 금액 (부가세 포함, PG 연동 대비) |
| expires_at | timestampz | 해당 포인트 묶음의 소멸 기한 (NULL 불가) |
| report_type | text | 차감 시: (market_analysis, business_insight) |
| created_at | timestampz | 거래 발생 시간 |

## 3. 백엔드 로직 및 API 구축

### 3.1. 포인트 차감 기준 상수 정의

| 리포트 유형 | 차감 포인트 |
|-------------|-------------|
| 시장 분석 리포트 | 400 포인트 |
| 비즈니스 인사이트 리포트 | 600 포인트 |

### 3.2. 정기 구독 및 충전 로직 API

**API 엔드포인트:** `/api/billing/handle-monthly-subscription`
(Stripe Webhook 또는 PG사 완료 신호 수신)

**로직:**
1. **결제 확인** (PG사 추후 보완): 결제 금액 11,000원(VAT 포함) 확인
2. **포인트 기록**: point_transactions에 10,000 포인트를 기록
3. **소멸 기한**: 이 포인트는 1개월 뒤로 expires_at을 설정
4. **자동 충전**: 모든 활성 회원에게 매월 1일/15일 등 지정된 날짜에 1,500 포인트를 충전하고, 이 포인트도 1개월 뒤 소멸 기한을 설정 (Cron Job 필요)

### 3.3. 추가 충전 및 보너스 로직 API

**API 엔드포인트:** `/api/billing/handle-addon-charge`

**로직:**
1. **결제 확인** (PG사 추후 보완): 사용자로부터 결제 금액(부가세 10% 포함)을 수신하고 확인
2. **기본 포인트 충전**: 결제 금액에서 부가세(10%)를 제외한 원금을 기본 포인트로 충전
3. **10% 보너스 크레딧 부여**: 결제 원금이 10,000원 이상일 경우, **결제 원금의 10%**를 보너스 포인트로 추가 충전
4. **소멸 기한**: 추가 충전된 모든 포인트는 3개월 뒤로 expires_at을 설정

### 3.4. 리포트 발행 포인트 차감 API (핵심 FEFO 로직)

**API 엔드포인트:** `/api/report/issue-and-charge`
(리포트 발행 요청 시 호출)

**로직:**
1. 사용자의 사용 가능 포인트를 확인
2. point_transactions 테이블에서 expires_at이 가장 가까운 포인트 묶음부터 순차적으로 차감하여 필요한 포인트를 충당 (FEFO)
3. 차감 후, **point_transactions**에 차감 내역을 기록하고 **user_point_balances**의 잔액을 업데이트

## 4. 프론트엔드 및 대시보드 표시

### 목표
사용자 대시보드에서 소멸 기한과 보너스 혜택을 명확하게 강조

### 4.1. 쿼터 현황 표시
- 현재 잔액을 **원화 금액(포인트)**으로 표시
- '가장 빠르게 소멸될 포인트 금액' 및 **'남은 일수'**를 경고색으로 대시보드에 명시
- **기본 잔여 포인트는 상단메뉴 사용자 표시 옆에 표시**

### 4.2. 추가 충전 UI
- 충전 옵션 선택 시, 10,000원 이상 결제일 경우 "10% 보너스 크레딧 + 3개월 소멸" 혜택 문구를 가장 크게 강조하여 구매를 유도

### 4.3. 차감 금액 투명성
- 리포트 생성 버튼 옆에 "400P 차감" 또는 "600P 차감" 문구를 명확하게 표시

## 5. 구현 단계별 계획

### Phase 1: 데이터베이스 설계 및 기본 API
1. Supabase 테이블 생성 (user_point_balances, point_transactions)
2. 기본 포인트 관리 API 구현
3. FEFO 로직 구현 및 테스트

### Phase 2: 결제 시스템 연동 준비
1. Stripe 또는 가상 결제 시스템 연동
2. Webhook 처리 로직 구현
3. 정기 구독 및 추가 충전 API 구현

### Phase 3: 프론트엔드 UI 구현
1. 포인트 잔액 표시 컴포넌트
2. 충전 UI 및 결제 플로우
3. 대시보드 포인트 현황 표시

### Phase 4: 자동화 및 최적화
1. Cron Job 설정 (정기 충전, 포인트 소멸)
2. 알림 시스템 구현
3. 성능 최적화 및 모니터링

## 6. 기술적 고려사항

### 6.1. 보안
- 결제 정보 암호화
- API 인증 및 권한 관리
- 포인트 조작 방지 로직

### 6.2. 성능
- 대용량 거래 데이터 처리
- 실시간 잔액 계산 최적화
- 캐싱 전략

### 6.3. 확장성
- 다양한 PG사 연동 대비 추상화
- 포인트 정책 변경 대응
- 국제화 대응 (다중 통화)

## 7. 테스트 계획

### 7.1. 단위 테스트
- FEFO 로직 테스트
- 포인트 계산 정확성 테스트
- API 엔드포인트 테스트

### 7.2. 통합 테스트
- 결제 플로우 전체 테스트
- 포인트 소멸 시나리오 테스트
- 동시성 처리 테스트

### 7.3. 사용자 테스트
- UI/UX 사용성 테스트
- 결제 프로세스 테스트
- 대시보드 정보 표시 테스트

---

**다음 단계:** 이 PRD를 바탕으로 구체적인 구현 작업을 시작할 수 있습니다. 우선순위에 따라 Phase 1부터 순차적으로 진행하는 것을 권장합니다.