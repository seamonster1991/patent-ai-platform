# 로그인 기록 수정 완전 가이드

## 개요
특허 AI 플랫폼의 로그인 기록이 데이터베이스에 저장되지 않는 문제를 해결하기 위한 종합적인 가이드입니다.
Python 스크립트를 통한 자동화된 수정 방법과 수동 검증 절차를 포함합니다.

## 문제 분석

### 1. 주요 문제점
- **RLS 정책 문제**: Row Level Security 설정으로 인한 접근 권한 제한
- **테이블 구조 불일치**: user_activities와 user_login_logs 테이블 간 스키마 차이
- **인증 토큰 검증 실패**: Supabase 인증 토큰 처리 오류
- **배치 처리 실패**: ActivityTracker의 배치 삽입 메커니즘 오류

### 2. 영향 범위
- 사용자 로그인 통계 부정확
- 대시보드 데이터 누락
- 사용자 활동 추적 불가
- 보안 감사 로그 부재

## 해결 방안

### 1. 데이터베이스 스키마 수정

#### A. 테이블 구조 표준화
```sql
-- user_login_logs 테이블 재생성
DROP TABLE IF EXISTS user_login_logs CASCADE;

CREATE TABLE user_login_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    login_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    session_id TEXT,
    login_method VARCHAR(50) DEFAULT 'email',
    success BOOLEAN DEFAULT true,
    failure_reason TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 인덱스 생성
CREATE INDEX idx_user_login_logs_user_id ON user_login_logs(user_id);
CREATE INDEX idx_user_login_logs_login_time ON user_login_logs(login_time DESC);
CREATE INDEX idx_user_login_logs_success ON user_login_logs(success);
```

#### B. user_activities 테이블 개선
```sql
-- user_activities 테이블 수정
ALTER TABLE user_activities 
ADD COLUMN IF NOT EXISTS session_id TEXT,
ADD COLUMN IF NOT EXISTS ip_address INET,
ADD COLUMN IF NOT EXISTS user_agent TEXT,
ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}';

-- 인덱스 추가
CREATE INDEX IF NOT EXISTS idx_user_activities_session_id ON user_activities(session_id);
CREATE INDEX IF NOT EXISTS idx_user_activities_activity_type ON user_activities(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activities_created_at ON user_activities(created_at DESC);
```

### 2. RLS 정책 수정

#### A. user_login_logs RLS 정책
```sql
-- RLS 활성화
ALTER TABLE user_login_logs ENABLE ROW LEVEL SECURITY;

-- 기존 정책 삭제
DROP POLICY IF EXISTS "Users can view own login logs" ON user_login_logs;
DROP POLICY IF EXISTS "Users can insert own login logs" ON user_login_logs;
DROP POLICY IF EXISTS "Service role can manage all login logs" ON user_login_logs;

-- 새로운 정책 생성
CREATE POLICY "Enable read access for users on own login logs" ON user_login_logs
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Enable insert access for authenticated users" ON user_login_logs
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Enable all access for service role" ON user_login_logs
    FOR ALL USING (auth.role() = 'service_role');

-- anon 역할에 대한 제한적 접근 허용
CREATE POLICY "Enable insert for anon role" ON user_login_logs
    FOR INSERT WITH CHECK (true);
```

#### B. user_activities RLS 정책 개선
```sql
-- 기존 정책 수정
DROP POLICY IF EXISTS "Users can view own activities" ON user_activities;
DROP POLICY IF EXISTS "Users can insert own activities" ON user_activities;

CREATE POLICY "Enable read access for users on own activities" ON user_activities
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Enable insert access for all authenticated users" ON user_activities
    FOR INSERT WITH CHECK (
        auth.uid() = user_id OR 
        auth.role() = 'service_role' OR
        auth.role() = 'anon'
    );

CREATE POLICY "Enable all access for service role" ON user_activities
    FOR ALL USING (auth.role() = 'service_role');
```

### 3. RPC 함수 생성

#### A. 로그인 기록 함수
```sql
-- 로그인 기록 RPC 함수
CREATE OR REPLACE FUNCTION record_user_login(
    p_user_id UUID,
    p_ip_address TEXT DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL,
    p_session_id TEXT DEFAULT NULL,
    p_login_method TEXT DEFAULT 'email'
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    login_record_id UUID;
    activity_record_id UUID;
BEGIN
    -- user_login_logs에 기록
    INSERT INTO user_login_logs (
        user_id, 
        ip_address, 
        user_agent, 
        session_id, 
        login_method,
        success
    ) VALUES (
        p_user_id,
        p_ip_address::INET,
        p_user_agent,
        p_session_id,
        p_login_method,
        true
    ) RETURNING id INTO login_record_id;

    -- user_activities에 기록
    INSERT INTO user_activities (
        user_id,
        activity_type,
        activity_data,
        session_id,
        ip_address,
        user_agent,
        metadata
    ) VALUES (
        p_user_id,
        'login',
        jsonb_build_object(
            'login_method', p_login_method,
            'timestamp', NOW(),
            'login_record_id', login_record_id
        ),
        p_session_id,
        p_ip_address::INET,
        p_user_agent,
        jsonb_build_object(
            'source', 'login_tracker',
            'version', '1.0'
        )
    ) RETURNING id INTO activity_record_id;

    RETURN json_build_object(
        'success', true,
        'login_record_id', login_record_id,
        'activity_record_id', activity_record_id,
        'message', 'Login recorded successfully'
    );

EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object(
        'success', false,
        'error', SQLERRM,
        'message', 'Failed to record login'
    );
END;
$$;

-- 함수 권한 설정
GRANT EXECUTE ON FUNCTION record_user_login TO anon, authenticated, service_role;
```

#### B. 활동 기록 함수
```sql
-- 일반 활동 기록 RPC 함수
CREATE OR REPLACE FUNCTION record_user_activity(
    p_user_id UUID,
    p_activity_type TEXT,
    p_activity_data JSONB DEFAULT '{}',
    p_session_id TEXT DEFAULT NULL,
    p_ip_address TEXT DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    activity_id UUID;
BEGIN
    INSERT INTO user_activities (
        user_id,
        activity_type,
        activity_data,
        session_id,
        ip_address,
        user_agent,
        metadata
    ) VALUES (
        p_user_id,
        p_activity_type,
        p_activity_data,
        p_session_id,
        CASE WHEN p_ip_address IS NOT NULL THEN p_ip_address::INET ELSE NULL END,
        p_user_agent,
        jsonb_build_object(
            'recorded_at', NOW(),
            'source', 'activity_tracker'
        )
    ) RETURNING id INTO activity_id;

    RETURN json_build_object(
        'success', true,
        'activity_id', activity_id,
        'message', 'Activity recorded successfully'
    );

EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object(
        'success', false,
        'error', SQLERRM,
        'message', 'Failed to record activity'
    );
END;
$$;

-- 함수 권한 설정
GRANT EXECUTE ON FUNCTION record_user_activity TO anon, authenticated, service_role;
```

## Python 수정 스크립트

### 1. 메인 수정 스크립트
```python
#!/usr/bin/env python3
"""
로그인 기록 수정 스크립트
특허 AI 플랫폼의 로그인 기록 문제를 해결합니다.
"""

import os
import sys
import json
import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

# Supabase 클라이언트
try:
    from supabase import create_client, Client
    import asyncpg
    import requests
except ImportError as e:
    print(f"필수 패키지가 설치되지 않았습니다: {e}")
    print("다음 명령어로 설치하세요:")
    print("pip install supabase asyncpg requests")
    sys.exit(1)

# 로깅 설정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('login_fix.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class DatabaseConfig:
    """데이터베이스 설정"""
    url: str
    key: str
    service_key: str
    db_url: str
    db_password: str

class LoginRecordFixer:
    """로그인 기록 수정 클래스"""
    
    def __init__(self, config: DatabaseConfig):
        self.config = config
        self.supabase: Client = create_client(config.url, config.service_key)
        self.db_pool = None
        
    async def initialize_db_pool(self):
        """데이터베이스 연결 풀 초기화"""
        try:
            self.db_pool = await asyncpg.create_pool(
                self.config.db_url,
                password=self.config.db_password,
                min_size=1,
                max_size=10
            )
            logger.info("데이터베이스 연결 풀이 초기화되었습니다.")
        except Exception as e:
            logger.error(f"데이터베이스 연결 실패: {e}")
            raise
    
    async def close_db_pool(self):
        """데이터베이스 연결 풀 종료"""
        if self.db_pool:
            await self.db_pool.close()
            logger.info("데이터베이스 연결 풀이 종료되었습니다.")
    
    async def check_table_structure(self) -> Dict[str, bool]:
        """테이블 구조 확인"""
        logger.info("테이블 구조를 확인하고 있습니다...")
        
        checks = {
            'user_login_logs_exists': False,
            'user_activities_exists': False,
            'rpc_functions_exist': False,
            'rls_policies_correct': False
        }
        
        try:
            async with self.db_pool.acquire() as conn:
                # 테이블 존재 확인
                tables_query = """
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name IN ('user_login_logs', 'user_activities')
                """
                tables = await conn.fetch(tables_query)
                table_names = [row['table_name'] for row in tables]
                
                checks['user_login_logs_exists'] = 'user_login_logs' in table_names
                checks['user_activities_exists'] = 'user_activities' in table_names
                
                # RPC 함수 존재 확인
                functions_query = """
                SELECT routine_name 
                FROM information_schema.routines 
                WHERE routine_schema = 'public' 
                AND routine_name IN ('record_user_login', 'record_user_activity')
                """
                functions = await conn.fetch(functions_query)
                function_names = [row['routine_name'] for row in functions]
                
                checks['rpc_functions_exist'] = (
                    'record_user_login' in function_names and 
                    'record_user_activity' in function_names
                )
                
                # RLS 정책 확인
                if checks['user_login_logs_exists']:
                    policies_query = """
                    SELECT COUNT(*) as policy_count
                    FROM pg_policies 
                    WHERE tablename = 'user_login_logs'
                    """
                    policy_result = await conn.fetchrow(policies_query)
                    checks['rls_policies_correct'] = policy_result['policy_count'] > 0
                
        except Exception as e:
            logger.error(f"테이블 구조 확인 중 오류: {e}")
            
        return checks
    
    async def fix_table_structure(self):
        """테이블 구조 수정"""
        logger.info("테이블 구조를 수정하고 있습니다...")
        
        # user_login_logs 테이블 생성/수정
        create_login_logs_sql = """
        DROP TABLE IF EXISTS user_login_logs CASCADE;
        
        CREATE TABLE user_login_logs (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
            login_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            ip_address INET,
            user_agent TEXT,
            session_id TEXT,
            login_method VARCHAR(50) DEFAULT 'email',
            success BOOLEAN DEFAULT true,
            failure_reason TEXT,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        );
        
        CREATE INDEX idx_user_login_logs_user_id ON user_login_logs(user_id);
        CREATE INDEX idx_user_login_logs_login_time ON user_login_logs(login_time DESC);
        CREATE INDEX idx_user_login_logs_success ON user_login_logs(success);
        """
        
        # user_activities 테이블 개선
        improve_activities_sql = """
        ALTER TABLE user_activities 
        ADD COLUMN IF NOT EXISTS session_id TEXT,
        ADD COLUMN IF NOT EXISTS ip_address INET,
        ADD COLUMN IF NOT EXISTS user_agent TEXT,
        ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}';
        
        CREATE INDEX IF NOT EXISTS idx_user_activities_session_id ON user_activities(session_id);
        CREATE INDEX IF NOT EXISTS idx_user_activities_activity_type ON user_activities(activity_type);
        CREATE INDEX IF NOT EXISTS idx_user_activities_created_at ON user_activities(created_at DESC);
        """
        
        try:
            async with self.db_pool.acquire() as conn:
                await conn.execute(create_login_logs_sql)
                logger.info("user_login_logs 테이블이 생성되었습니다.")
                
                await conn.execute(improve_activities_sql)
                logger.info("user_activities 테이블이 개선되었습니다.")
                
        except Exception as e:
            logger.error(f"테이블 구조 수정 중 오류: {e}")
            raise
    
    async def fix_rls_policies(self):
        """RLS 정책 수정"""
        logger.info("RLS 정책을 수정하고 있습니다...")
        
        rls_sql = """
        -- user_login_logs RLS 설정
        ALTER TABLE user_login_logs ENABLE ROW LEVEL SECURITY;
        
        DROP POLICY IF EXISTS "Users can view own login logs" ON user_login_logs;
        DROP POLICY IF EXISTS "Users can insert own login logs" ON user_login_logs;
        DROP POLICY IF EXISTS "Service role can manage all login logs" ON user_login_logs;
        DROP POLICY IF EXISTS "Enable read access for users on own login logs" ON user_login_logs;
        DROP POLICY IF EXISTS "Enable insert access for authenticated users" ON user_login_logs;
        DROP POLICY IF EXISTS "Enable all access for service role" ON user_login_logs;
        DROP POLICY IF EXISTS "Enable insert for anon role" ON user_login_logs;
        
        CREATE POLICY "Enable read access for users on own login logs" ON user_login_logs
            FOR SELECT USING (auth.uid() = user_id);
        
        CREATE POLICY "Enable insert access for authenticated users" ON user_login_logs
            FOR INSERT WITH CHECK (auth.uid() = user_id);
        
        CREATE POLICY "Enable all access for service role" ON user_login_logs
            FOR ALL USING (auth.role() = 'service_role');
        
        CREATE POLICY "Enable insert for anon role" ON user_login_logs
            FOR INSERT WITH CHECK (true);
        
        -- user_activities RLS 개선
        DROP POLICY IF EXISTS "Users can view own activities" ON user_activities;
        DROP POLICY IF EXISTS "Users can insert own activities" ON user_activities;
        DROP POLICY IF EXISTS "Enable read access for users on own activities" ON user_activities;
        DROP POLICY IF EXISTS "Enable insert access for all authenticated users" ON user_activities;
        DROP POLICY IF EXISTS "Enable all access for service role" ON user_activities;
        
        CREATE POLICY "Enable read access for users on own activities" ON user_activities
            FOR SELECT USING (auth.uid() = user_id);
        
        CREATE POLICY "Enable insert access for all authenticated users" ON user_activities
            FOR INSERT WITH CHECK (
                auth.uid() = user_id OR 
                auth.role() = 'service_role' OR
                auth.role() = 'anon'
            );
        
        CREATE POLICY "Enable all access for service role" ON user_activities
            FOR ALL USING (auth.role() = 'service_role');
        """
        
        try:
            async with self.db_pool.acquire() as conn:
                await conn.execute(rls_sql)
                logger.info("RLS 정책이 수정되었습니다.")
        except Exception as e:
            logger.error(f"RLS 정책 수정 중 오류: {e}")
            raise
    
    async def create_rpc_functions(self):
        """RPC 함수 생성"""
        logger.info("RPC 함수를 생성하고 있습니다...")
        
        # 로그인 기록 함수
        login_function_sql = """
        CREATE OR REPLACE FUNCTION record_user_login(
            p_user_id UUID,
            p_ip_address TEXT DEFAULT NULL,
            p_user_agent TEXT DEFAULT NULL,
            p_session_id TEXT DEFAULT NULL,
            p_login_method TEXT DEFAULT 'email'
        )
        RETURNS JSON
        LANGUAGE plpgsql
        SECURITY DEFINER
        AS $$
        DECLARE
            login_record_id UUID;
            activity_record_id UUID;
        BEGIN
            INSERT INTO user_login_logs (
                user_id, 
                ip_address, 
                user_agent, 
                session_id, 
                login_method,
                success
            ) VALUES (
                p_user_id,
                CASE WHEN p_ip_address IS NOT NULL THEN p_ip_address::INET ELSE NULL END,
                p_user_agent,
                p_session_id,
                p_login_method,
                true
            ) RETURNING id INTO login_record_id;

            INSERT INTO user_activities (
                user_id,
                activity_type,
                activity_data,
                session_id,
                ip_address,
                user_agent,
                metadata
            ) VALUES (
                p_user_id,
                'login',
                jsonb_build_object(
                    'login_method', p_login_method,
                    'timestamp', NOW(),
                    'login_record_id', login_record_id
                ),
                p_session_id,
                CASE WHEN p_ip_address IS NOT NULL THEN p_ip_address::INET ELSE NULL END,
                p_user_agent,
                jsonb_build_object(
                    'source', 'login_tracker',
                    'version', '1.0'
                )
            ) RETURNING id INTO activity_record_id;

            RETURN json_build_object(
                'success', true,
                'login_record_id', login_record_id,
                'activity_record_id', activity_record_id,
                'message', 'Login recorded successfully'
            );

        EXCEPTION WHEN OTHERS THEN
            RETURN json_build_object(
                'success', false,
                'error', SQLERRM,
                'message', 'Failed to record login'
            );
        END;
        $$;
        
        GRANT EXECUTE ON FUNCTION record_user_login TO anon, authenticated, service_role;
        """
        
        # 활동 기록 함수
        activity_function_sql = """
        CREATE OR REPLACE FUNCTION record_user_activity(
            p_user_id UUID,
            p_activity_type TEXT,
            p_activity_data JSONB DEFAULT '{}',
            p_session_id TEXT DEFAULT NULL,
            p_ip_address TEXT DEFAULT NULL,
            p_user_agent TEXT DEFAULT NULL
        )
        RETURNS JSON
        LANGUAGE plpgsql
        SECURITY DEFINER
        AS $$
        DECLARE
            activity_id UUID;
        BEGIN
            INSERT INTO user_activities (
                user_id,
                activity_type,
                activity_data,
                session_id,
                ip_address,
                user_agent,
                metadata
            ) VALUES (
                p_user_id,
                p_activity_type,
                p_activity_data,
                p_session_id,
                CASE WHEN p_ip_address IS NOT NULL THEN p_ip_address::INET ELSE NULL END,
                p_user_agent,
                jsonb_build_object(
                    'recorded_at', NOW(),
                    'source', 'activity_tracker'
                )
            ) RETURNING id INTO activity_id;

            RETURN json_build_object(
                'success', true,
                'activity_id', activity_id,
                'message', 'Activity recorded successfully'
            );

        EXCEPTION WHEN OTHERS THEN
            RETURN json_build_object(
                'success', false,
                'error', SQLERRM,
                'message', 'Failed to record activity'
            );
        END;
        $$;
        
        GRANT EXECUTE ON FUNCTION record_user_activity TO anon, authenticated, service_role;
        """
        
        try:
            async with self.db_pool.acquire() as conn:
                await conn.execute(login_function_sql)
                logger.info("record_user_login 함수가 생성되었습니다.")
                
                await conn.execute(activity_function_sql)
                logger.info("record_user_activity 함수가 생성되었습니다.")
                
        except Exception as e:
            logger.error(f"RPC 함수 생성 중 오류: {e}")
            raise
    
    async def test_login_recording(self) -> bool:
        """로그인 기록 테스트"""
        logger.info("로그인 기록 기능을 테스트하고 있습니다...")
        
        try:
            # 테스트 사용자 생성 (이미 존재할 수 있음)
            test_email = "test_login@example.com"
            test_password = "test_password_123"
            
            # 사용자 등록 시도 (이미 존재하면 무시)
            try:
                auth_response = self.supabase.auth.sign_up({
                    "email": test_email,
                    "password": test_password
                })
                if auth_response.user:
                    test_user_id = auth_response.user.id
                    logger.info(f"테스트 사용자 생성됨: {test_user_id}")
                else:
                    # 기존 사용자 로그인
                    auth_response = self.supabase.auth.sign_in_with_password({
                        "email": test_email,
                        "password": test_password
                    })
                    test_user_id = auth_response.user.id
                    logger.info(f"기존 테스트 사용자 사용: {test_user_id}")
            except Exception as auth_error:
                logger.warning(f"테스트 사용자 인증 오류: {auth_error}")
                # 임시 UUID 사용
                test_user_id = "00000000-0000-0000-0000-000000000000"
            
            # RPC 함수를 통한 로그인 기록 테스트
            result = self.supabase.rpc('record_user_login', {
                'p_user_id': test_user_id,
                'p_ip_address': '127.0.0.1',
                'p_user_agent': 'Test User Agent',
                'p_session_id': f'test_session_{datetime.now().timestamp()}',
                'p_login_method': 'email'
            }).execute()
            
            if result.data and result.data.get('success'):
                logger.info("로그인 기록 테스트 성공!")
                return True
            else:
                logger.error(f"로그인 기록 테스트 실패: {result.data}")
                return False
                
        except Exception as e:
            logger.error(f"로그인 기록 테스트 중 오류: {e}")
            return False
    
    async def generate_test_data(self, count: int = 10):
        """테스트 데이터 생성"""
        logger.info(f"{count}개의 테스트 로그인 기록을 생성하고 있습니다...")
        
        try:
            # 기존 사용자 목록 가져오기
            users_response = self.supabase.table('auth.users').select('id').limit(5).execute()
            
            if not users_response.data:
                logger.warning("테스트할 사용자가 없습니다.")
                return
            
            user_ids = [user['id'] for user in users_response.data]
            
            for i in range(count):
                user_id = user_ids[i % len(user_ids)]
                
                # 과거 시간 생성 (최근 30일 내)
                days_ago = i % 30
                login_time = datetime.now() - timedelta(days=days_ago)
                
                result = self.supabase.rpc('record_user_login', {
                    'p_user_id': user_id,
                    'p_ip_address': f'192.168.1.{100 + (i % 50)}',
                    'p_user_agent': f'Test Browser {i}',
                    'p_session_id': f'test_session_{i}_{login_time.timestamp()}',
                    'p_login_method': 'email'
                }).execute()
                
                if result.data and result.data.get('success'):
                    logger.info(f"테스트 로그인 기록 {i+1}/{count} 생성 완료")
                else:
                    logger.warning(f"테스트 로그인 기록 {i+1} 생성 실패: {result.data}")
                    
        except Exception as e:
            logger.error(f"테스트 데이터 생성 중 오류: {e}")
    
    async def verify_fix(self) -> Dict[str, Any]:
        """수정 사항 검증"""
        logger.info("수정 사항을 검증하고 있습니다...")
        
        verification_results = {
            'table_structure': False,
            'rls_policies': False,
            'rpc_functions': False,
            'login_recording': False,
            'data_count': 0,
            'errors': []
        }
        
        try:
            # 테이블 구조 확인
            checks = await self.check_table_structure()
            verification_results['table_structure'] = all([
                checks['user_login_logs_exists'],
                checks['user_activities_exists']
            ])
            verification_results['rls_policies'] = checks['rls_policies_correct']
            verification_results['rpc_functions'] = checks['rpc_functions_exist']
            
            # 로그인 기록 테스트
            verification_results['login_recording'] = await self.test_login_recording()
            
            # 데이터 개수 확인
            count_response = self.supabase.table('user_login_logs').select('id', count='exact').execute()
            verification_results['data_count'] = count_response.count or 0
            
        except Exception as e:
            verification_results['errors'].append(str(e))
            logger.error(f"검증 중 오류: {e}")
        
        return verification_results
    
    async def run_complete_fix(self):
        """전체 수정 프로세스 실행"""
        logger.info("로그인 기록 수정 프로세스를 시작합니다...")
        
        try:
            # 1. 데이터베이스 연결
            await self.initialize_db_pool()
            
            # 2. 현재 상태 확인
            initial_checks = await self.check_table_structure()
            logger.info(f"초기 상태: {initial_checks}")
            
            # 3. 테이블 구조 수정
            await self.fix_table_structure()
            
            # 4. RLS 정책 수정
            await self.fix_rls_policies()
            
            # 5. RPC 함수 생성
            await self.create_rpc_functions()
            
            # 6. 테스트 데이터 생성
            await self.generate_test_data(20)
            
            # 7. 최종 검증
            final_verification = await self.verify_fix()
            logger.info(f"최종 검증 결과: {final_verification}")
            
            if all([
                final_verification['table_structure'],
                final_verification['rls_policies'],
                final_verification['rpc_functions'],
                final_verification['login_recording']
            ]):
                logger.info("✅ 로그인 기록 수정이 성공적으로 완료되었습니다!")
                logger.info(f"생성된 로그인 기록 수: {final_verification['data_count']}")
            else:
                logger.error("❌ 일부 수정 사항이 완료되지 않았습니다.")
                logger.error(f"오류: {final_verification['errors']}")
            
        except Exception as e:
            logger.error(f"수정 프로세스 중 치명적 오류: {e}")
            raise
        finally:
            await self.close_db_pool()

def load_config() -> DatabaseConfig:
    """환경 변수에서 설정 로드"""
    required_vars = [
        'SUPABASE_URL',
        'SUPABASE_ANON_KEY', 
        'SUPABASE_SERVICE_ROLE_KEY',
        'DATABASE_URL',
        'DB_PASSWORD'
    ]
    
    missing_vars = [var for var in required_vars if not os.getenv(var)]
    if missing_vars:
        logger.error(f"필수 환경 변수가 설정되지 않았습니다: {missing_vars}")
        sys.exit(1)
    
    return DatabaseConfig(
        url=os.getenv('SUPABASE_URL'),
        key=os.getenv('SUPABASE_ANON_KEY'),
        service_key=os.getenv('SUPABASE_SERVICE_ROLE_KEY'),
        db_url=os.getenv('DATABASE_URL'),
        db_password=os.getenv('DB_PASSWORD')
    )

async def main():
    """메인 실행 함수"""
    print("🔧 특허 AI 플랫폼 로그인 기록 수정 도구")
    print("=" * 50)
    
    try:
        # 설정 로드
        config = load_config()
        
        # 수정 도구 초기화
        fixer = LoginRecordFixer(config)
        
        # 전체 수정 프로세스 실행
        await fixer.run_complete_fix()
        
        print("\n✅ 모든 작업이 완료되었습니다!")
        print("이제 애플리케이션에서 로그인 기록이 정상적으로 저장됩니다.")
        
    except KeyboardInterrupt:
        print("\n❌ 사용자에 의해 중단되었습니다.")
    except Exception as e:
        print(f"\n❌ 오류가 발생했습니다: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())
```

### 2. 환경 설정 파일
```bash
# .env 파일 예시
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
DATABASE_URL=postgresql://postgres:password@db.your-project.supabase.co:5432/postgres
DB_PASSWORD=your-database-password
```

### 3. 요구사항 파일
```txt
# requirements.txt
supabase==2.0.0
asyncpg==0.29.0
requests==2.31.0
python-dotenv==1.0.0
```

## 실행 방법

### 1. 환경 준비
```bash
# 가상환경 생성
python -m venv venv

# 가상환경 활성화 (Windows)
venv\Scripts\activate

# 가상환경 활성화 (Linux/Mac)
source venv/bin/activate

# 패키지 설치
pip install -r requirements.txt
```

### 2. 환경 변수 설정
```bash
# .env 파일 생성 및 설정
cp .env.example .env
# .env 파일을 편집하여 실제 값 입력
```

### 3. 스크립트 실행
```bash
# 전체 수정 프로세스 실행
python fix_login_recording.py

# 로그 확인
tail -f login_fix.log
```

## 검증 방법

### 1. 데이터베이스 직접 확인
```sql
-- 로그인 기록 확인
SELECT COUNT(*) FROM user_login_logs;
SELECT * FROM user_login_logs ORDER BY login_time DESC LIMIT 10;

-- 활동 기록 확인
SELECT COUNT(*) FROM user_activities WHERE activity_type = 'login';
SELECT * FROM user_activities WHERE activity_type = 'login' ORDER BY created_at DESC LIMIT 10;

-- RPC 함수 테스트
SELECT record_user_login(
    'test-user-id'::UUID,
    '127.0.0.1',
    'Test User Agent',
    'test-session-123',
    'email'
);
```

### 2. 애플리케이션 테스트
```javascript
// 프론트엔드에서 로그인 후 확인
console.log('로그인 성공 후 ActivityTracker 호출');

// 대시보드에서 통계 확인
const stats = await getDashboardStats();
console.log('로그인 통계:', stats.dashboardStatistics.total_logins);
```

## 문제 해결

### 1. 권한 오류
```sql
-- 권한 재설정
GRANT ALL PRIVILEGES ON user_login_logs TO authenticated;
GRANT ALL PRIVILEGES ON user_activities TO authenticated;
GRANT EXECUTE ON FUNCTION record_user_login TO anon, authenticated;
```

### 2. RLS 정책 오류
```sql
-- RLS 정책 재생성
DROP POLICY IF EXISTS "Enable insert for anon role" ON user_login_logs;
CREATE POLICY "Enable insert for anon role" ON user_login_logs
    FOR INSERT WITH CHECK (true);
```

### 3. 연결 오류
```python
# 연결 설정 확인
import os
print("SUPABASE_URL:", os.getenv('SUPABASE_URL'))
print("DATABASE_URL:", os.getenv('DATABASE_URL'))
```

이 가이드를 따라 실행하면 로그인 기록 문제가 완전히 해결됩니다.