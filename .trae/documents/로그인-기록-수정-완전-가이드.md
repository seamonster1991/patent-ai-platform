# ë¡œê·¸ì¸ ê¸°ë¡ ìˆ˜ì • ì™„ì „ ê°€ì´ë“œ

## ê°œìš”
íŠ¹í—ˆ AI í”Œë«í¼ì˜ ë¡œê·¸ì¸ ê¸°ë¡ì´ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ë˜ì§€ ì•ŠëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ì¢…í•©ì ì¸ ê°€ì´ë“œì…ë‹ˆë‹¤.
Python ìŠ¤í¬ë¦½íŠ¸ë¥¼ í†µí•œ ìë™í™”ëœ ìˆ˜ì • ë°©ë²•ê³¼ ìˆ˜ë™ ê²€ì¦ ì ˆì°¨ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.

## ë¬¸ì œ ë¶„ì„

### 1. ì£¼ìš” ë¬¸ì œì 
- **RLS ì •ì±… ë¬¸ì œ**: Row Level Security ì„¤ì •ìœ¼ë¡œ ì¸í•œ ì ‘ê·¼ ê¶Œí•œ ì œí•œ
- **í…Œì´ë¸” êµ¬ì¡° ë¶ˆì¼ì¹˜**: user_activitiesì™€ user_login_logs í…Œì´ë¸” ê°„ ìŠ¤í‚¤ë§ˆ ì°¨ì´
- **ì¸ì¦ í† í° ê²€ì¦ ì‹¤íŒ¨**: Supabase ì¸ì¦ í† í° ì²˜ë¦¬ ì˜¤ë¥˜
- **ë°°ì¹˜ ì²˜ë¦¬ ì‹¤íŒ¨**: ActivityTrackerì˜ ë°°ì¹˜ ì‚½ì… ë©”ì»¤ë‹ˆì¦˜ ì˜¤ë¥˜

### 2. ì˜í–¥ ë²”ìœ„
- ì‚¬ìš©ì ë¡œê·¸ì¸ í†µê³„ ë¶€ì •í™•
- ëŒ€ì‹œë³´ë“œ ë°ì´í„° ëˆ„ë½
- ì‚¬ìš©ì í™œë™ ì¶”ì  ë¶ˆê°€
- ë³´ì•ˆ ê°ì‚¬ ë¡œê·¸ ë¶€ì¬

## í•´ê²° ë°©ì•ˆ

### 1. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ìˆ˜ì •

#### A. í…Œì´ë¸” êµ¬ì¡° í‘œì¤€í™”
```sql
-- user_login_logs í…Œì´ë¸” ì¬ìƒì„±
DROP TABLE IF EXISTS user_login_logs CASCADE;

CREATE TABLE user_login_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    login_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    session_id TEXT,
    login_method VARCHAR(50) DEFAULT 'email',
    success BOOLEAN DEFAULT true,
    failure_reason TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_user_login_logs_user_id ON user_login_logs(user_id);
CREATE INDEX idx_user_login_logs_login_time ON user_login_logs(login_time DESC);
CREATE INDEX idx_user_login_logs_success ON user_login_logs(success);
```

#### B. user_activities í…Œì´ë¸” ê°œì„ 
```sql
-- user_activities í…Œì´ë¸” ìˆ˜ì •
ALTER TABLE user_activities 
ADD COLUMN IF NOT EXISTS session_id TEXT,
ADD COLUMN IF NOT EXISTS ip_address INET,
ADD COLUMN IF NOT EXISTS user_agent TEXT,
ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}';

-- ì¸ë±ìŠ¤ ì¶”ê°€
CREATE INDEX IF NOT EXISTS idx_user_activities_session_id ON user_activities(session_id);
CREATE INDEX IF NOT EXISTS idx_user_activities_activity_type ON user_activities(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activities_created_at ON user_activities(created_at DESC);
```

### 2. RLS ì •ì±… ìˆ˜ì •

#### A. user_login_logs RLS ì •ì±…
```sql
-- RLS í™œì„±í™”
ALTER TABLE user_login_logs ENABLE ROW LEVEL SECURITY;

-- ê¸°ì¡´ ì •ì±… ì‚­ì œ
DROP POLICY IF EXISTS "Users can view own login logs" ON user_login_logs;
DROP POLICY IF EXISTS "Users can insert own login logs" ON user_login_logs;
DROP POLICY IF EXISTS "Service role can manage all login logs" ON user_login_logs;

-- ìƒˆë¡œìš´ ì •ì±… ìƒì„±
CREATE POLICY "Enable read access for users on own login logs" ON user_login_logs
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Enable insert access for authenticated users" ON user_login_logs
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Enable all access for service role" ON user_login_logs
    FOR ALL USING (auth.role() = 'service_role');

-- anon ì—­í• ì— ëŒ€í•œ ì œí•œì  ì ‘ê·¼ í—ˆìš©
CREATE POLICY "Enable insert for anon role" ON user_login_logs
    FOR INSERT WITH CHECK (true);
```

#### B. user_activities RLS ì •ì±… ê°œì„ 
```sql
-- ê¸°ì¡´ ì •ì±… ìˆ˜ì •
DROP POLICY IF EXISTS "Users can view own activities" ON user_activities;
DROP POLICY IF EXISTS "Users can insert own activities" ON user_activities;

CREATE POLICY "Enable read access for users on own activities" ON user_activities
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Enable insert access for all authenticated users" ON user_activities
    FOR INSERT WITH CHECK (
        auth.uid() = user_id OR 
        auth.role() = 'service_role' OR
        auth.role() = 'anon'
    );

CREATE POLICY "Enable all access for service role" ON user_activities
    FOR ALL USING (auth.role() = 'service_role');
```

### 3. RPC í•¨ìˆ˜ ìƒì„±

#### A. ë¡œê·¸ì¸ ê¸°ë¡ í•¨ìˆ˜
```sql
-- ë¡œê·¸ì¸ ê¸°ë¡ RPC í•¨ìˆ˜
CREATE OR REPLACE FUNCTION record_user_login(
    p_user_id UUID,
    p_ip_address TEXT DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL,
    p_session_id TEXT DEFAULT NULL,
    p_login_method TEXT DEFAULT 'email'
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    login_record_id UUID;
    activity_record_id UUID;
BEGIN
    -- user_login_logsì— ê¸°ë¡
    INSERT INTO user_login_logs (
        user_id, 
        ip_address, 
        user_agent, 
        session_id, 
        login_method,
        success
    ) VALUES (
        p_user_id,
        p_ip_address::INET,
        p_user_agent,
        p_session_id,
        p_login_method,
        true
    ) RETURNING id INTO login_record_id;

    -- user_activitiesì— ê¸°ë¡
    INSERT INTO user_activities (
        user_id,
        activity_type,
        activity_data,
        session_id,
        ip_address,
        user_agent,
        metadata
    ) VALUES (
        p_user_id,
        'login',
        jsonb_build_object(
            'login_method', p_login_method,
            'timestamp', NOW(),
            'login_record_id', login_record_id
        ),
        p_session_id,
        p_ip_address::INET,
        p_user_agent,
        jsonb_build_object(
            'source', 'login_tracker',
            'version', '1.0'
        )
    ) RETURNING id INTO activity_record_id;

    RETURN json_build_object(
        'success', true,
        'login_record_id', login_record_id,
        'activity_record_id', activity_record_id,
        'message', 'Login recorded successfully'
    );

EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object(
        'success', false,
        'error', SQLERRM,
        'message', 'Failed to record login'
    );
END;
$$;

-- í•¨ìˆ˜ ê¶Œí•œ ì„¤ì •
GRANT EXECUTE ON FUNCTION record_user_login TO anon, authenticated, service_role;
```

#### B. í™œë™ ê¸°ë¡ í•¨ìˆ˜
```sql
-- ì¼ë°˜ í™œë™ ê¸°ë¡ RPC í•¨ìˆ˜
CREATE OR REPLACE FUNCTION record_user_activity(
    p_user_id UUID,
    p_activity_type TEXT,
    p_activity_data JSONB DEFAULT '{}',
    p_session_id TEXT DEFAULT NULL,
    p_ip_address TEXT DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    activity_id UUID;
BEGIN
    INSERT INTO user_activities (
        user_id,
        activity_type,
        activity_data,
        session_id,
        ip_address,
        user_agent,
        metadata
    ) VALUES (
        p_user_id,
        p_activity_type,
        p_activity_data,
        p_session_id,
        CASE WHEN p_ip_address IS NOT NULL THEN p_ip_address::INET ELSE NULL END,
        p_user_agent,
        jsonb_build_object(
            'recorded_at', NOW(),
            'source', 'activity_tracker'
        )
    ) RETURNING id INTO activity_id;

    RETURN json_build_object(
        'success', true,
        'activity_id', activity_id,
        'message', 'Activity recorded successfully'
    );

EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object(
        'success', false,
        'error', SQLERRM,
        'message', 'Failed to record activity'
    );
END;
$$;

-- í•¨ìˆ˜ ê¶Œí•œ ì„¤ì •
GRANT EXECUTE ON FUNCTION record_user_activity TO anon, authenticated, service_role;
```

## Python ìˆ˜ì • ìŠ¤í¬ë¦½íŠ¸

### 1. ë©”ì¸ ìˆ˜ì • ìŠ¤í¬ë¦½íŠ¸
```python
#!/usr/bin/env python3
"""
ë¡œê·¸ì¸ ê¸°ë¡ ìˆ˜ì • ìŠ¤í¬ë¦½íŠ¸
íŠ¹í—ˆ AI í”Œë«í¼ì˜ ë¡œê·¸ì¸ ê¸°ë¡ ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤.
"""

import os
import sys
import json
import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

# Supabase í´ë¼ì´ì–¸íŠ¸
try:
    from supabase import create_client, Client
    import asyncpg
    import requests
except ImportError as e:
    print(f"í•„ìˆ˜ íŒ¨í‚¤ì§€ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤: {e}")
    print("ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ì„¤ì¹˜í•˜ì„¸ìš”:")
    print("pip install supabase asyncpg requests")
    sys.exit(1)

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('login_fix.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class DatabaseConfig:
    """ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •"""
    url: str
    key: str
    service_key: str
    db_url: str
    db_password: str

class LoginRecordFixer:
    """ë¡œê·¸ì¸ ê¸°ë¡ ìˆ˜ì • í´ë˜ìŠ¤"""
    
    def __init__(self, config: DatabaseConfig):
        self.config = config
        self.supabase: Client = create_client(config.url, config.service_key)
        self.db_pool = None
        
    async def initialize_db_pool(self):
        """ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ ì´ˆê¸°í™”"""
        try:
            self.db_pool = await asyncpg.create_pool(
                self.config.db_url,
                password=self.config.db_password,
                min_size=1,
                max_size=10
            )
            logger.info("ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.")
        except Exception as e:
            logger.error(f"ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨: {e}")
            raise
    
    async def close_db_pool(self):
        """ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ ì¢…ë£Œ"""
        if self.db_pool:
            await self.db_pool.close()
            logger.info("ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í’€ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
    
    async def check_table_structure(self) -> Dict[str, bool]:
        """í…Œì´ë¸” êµ¬ì¡° í™•ì¸"""
        logger.info("í…Œì´ë¸” êµ¬ì¡°ë¥¼ í™•ì¸í•˜ê³  ìˆìŠµë‹ˆë‹¤...")
        
        checks = {
            'user_login_logs_exists': False,
            'user_activities_exists': False,
            'rpc_functions_exist': False,
            'rls_policies_correct': False
        }
        
        try:
            async with self.db_pool.acquire() as conn:
                # í…Œì´ë¸” ì¡´ì¬ í™•ì¸
                tables_query = """
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name IN ('user_login_logs', 'user_activities')
                """
                tables = await conn.fetch(tables_query)
                table_names = [row['table_name'] for row in tables]
                
                checks['user_login_logs_exists'] = 'user_login_logs' in table_names
                checks['user_activities_exists'] = 'user_activities' in table_names
                
                # RPC í•¨ìˆ˜ ì¡´ì¬ í™•ì¸
                functions_query = """
                SELECT routine_name 
                FROM information_schema.routines 
                WHERE routine_schema = 'public' 
                AND routine_name IN ('record_user_login', 'record_user_activity')
                """
                functions = await conn.fetch(functions_query)
                function_names = [row['routine_name'] for row in functions]
                
                checks['rpc_functions_exist'] = (
                    'record_user_login' in function_names and 
                    'record_user_activity' in function_names
                )
                
                # RLS ì •ì±… í™•ì¸
                if checks['user_login_logs_exists']:
                    policies_query = """
                    SELECT COUNT(*) as policy_count
                    FROM pg_policies 
                    WHERE tablename = 'user_login_logs'
                    """
                    policy_result = await conn.fetchrow(policies_query)
                    checks['rls_policies_correct'] = policy_result['policy_count'] > 0
                
        except Exception as e:
            logger.error(f"í…Œì´ë¸” êµ¬ì¡° í™•ì¸ ì¤‘ ì˜¤ë¥˜: {e}")
            
        return checks
    
    async def fix_table_structure(self):
        """í…Œì´ë¸” êµ¬ì¡° ìˆ˜ì •"""
        logger.info("í…Œì´ë¸” êµ¬ì¡°ë¥¼ ìˆ˜ì •í•˜ê³  ìˆìŠµë‹ˆë‹¤...")
        
        # user_login_logs í…Œì´ë¸” ìƒì„±/ìˆ˜ì •
        create_login_logs_sql = """
        DROP TABLE IF EXISTS user_login_logs CASCADE;
        
        CREATE TABLE user_login_logs (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
            login_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            ip_address INET,
            user_agent TEXT,
            session_id TEXT,
            login_method VARCHAR(50) DEFAULT 'email',
            success BOOLEAN DEFAULT true,
            failure_reason TEXT,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        );
        
        CREATE INDEX idx_user_login_logs_user_id ON user_login_logs(user_id);
        CREATE INDEX idx_user_login_logs_login_time ON user_login_logs(login_time DESC);
        CREATE INDEX idx_user_login_logs_success ON user_login_logs(success);
        """
        
        # user_activities í…Œì´ë¸” ê°œì„ 
        improve_activities_sql = """
        ALTER TABLE user_activities 
        ADD COLUMN IF NOT EXISTS session_id TEXT,
        ADD COLUMN IF NOT EXISTS ip_address INET,
        ADD COLUMN IF NOT EXISTS user_agent TEXT,
        ADD COLUMN IF NOT EXISTS metadata JSONB DEFAULT '{}';
        
        CREATE INDEX IF NOT EXISTS idx_user_activities_session_id ON user_activities(session_id);
        CREATE INDEX IF NOT EXISTS idx_user_activities_activity_type ON user_activities(activity_type);
        CREATE INDEX IF NOT EXISTS idx_user_activities_created_at ON user_activities(created_at DESC);
        """
        
        try:
            async with self.db_pool.acquire() as conn:
                await conn.execute(create_login_logs_sql)
                logger.info("user_login_logs í…Œì´ë¸”ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.")
                
                await conn.execute(improve_activities_sql)
                logger.info("user_activities í…Œì´ë¸”ì´ ê°œì„ ë˜ì—ˆìŠµë‹ˆë‹¤.")
                
        except Exception as e:
            logger.error(f"í…Œì´ë¸” êµ¬ì¡° ìˆ˜ì • ì¤‘ ì˜¤ë¥˜: {e}")
            raise
    
    async def fix_rls_policies(self):
        """RLS ì •ì±… ìˆ˜ì •"""
        logger.info("RLS ì •ì±…ì„ ìˆ˜ì •í•˜ê³  ìˆìŠµë‹ˆë‹¤...")
        
        rls_sql = """
        -- user_login_logs RLS ì„¤ì •
        ALTER TABLE user_login_logs ENABLE ROW LEVEL SECURITY;
        
        DROP POLICY IF EXISTS "Users can view own login logs" ON user_login_logs;
        DROP POLICY IF EXISTS "Users can insert own login logs" ON user_login_logs;
        DROP POLICY IF EXISTS "Service role can manage all login logs" ON user_login_logs;
        DROP POLICY IF EXISTS "Enable read access for users on own login logs" ON user_login_logs;
        DROP POLICY IF EXISTS "Enable insert access for authenticated users" ON user_login_logs;
        DROP POLICY IF EXISTS "Enable all access for service role" ON user_login_logs;
        DROP POLICY IF EXISTS "Enable insert for anon role" ON user_login_logs;
        
        CREATE POLICY "Enable read access for users on own login logs" ON user_login_logs
            FOR SELECT USING (auth.uid() = user_id);
        
        CREATE POLICY "Enable insert access for authenticated users" ON user_login_logs
            FOR INSERT WITH CHECK (auth.uid() = user_id);
        
        CREATE POLICY "Enable all access for service role" ON user_login_logs
            FOR ALL USING (auth.role() = 'service_role');
        
        CREATE POLICY "Enable insert for anon role" ON user_login_logs
            FOR INSERT WITH CHECK (true);
        
        -- user_activities RLS ê°œì„ 
        DROP POLICY IF EXISTS "Users can view own activities" ON user_activities;
        DROP POLICY IF EXISTS "Users can insert own activities" ON user_activities;
        DROP POLICY IF EXISTS "Enable read access for users on own activities" ON user_activities;
        DROP POLICY IF EXISTS "Enable insert access for all authenticated users" ON user_activities;
        DROP POLICY IF EXISTS "Enable all access for service role" ON user_activities;
        
        CREATE POLICY "Enable read access for users on own activities" ON user_activities
            FOR SELECT USING (auth.uid() = user_id);
        
        CREATE POLICY "Enable insert access for all authenticated users" ON user_activities
            FOR INSERT WITH CHECK (
                auth.uid() = user_id OR 
                auth.role() = 'service_role' OR
                auth.role() = 'anon'
            );
        
        CREATE POLICY "Enable all access for service role" ON user_activities
            FOR ALL USING (auth.role() = 'service_role');
        """
        
        try:
            async with self.db_pool.acquire() as conn:
                await conn.execute(rls_sql)
                logger.info("RLS ì •ì±…ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.")
        except Exception as e:
            logger.error(f"RLS ì •ì±… ìˆ˜ì • ì¤‘ ì˜¤ë¥˜: {e}")
            raise
    
    async def create_rpc_functions(self):
        """RPC í•¨ìˆ˜ ìƒì„±"""
        logger.info("RPC í•¨ìˆ˜ë¥¼ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...")
        
        # ë¡œê·¸ì¸ ê¸°ë¡ í•¨ìˆ˜
        login_function_sql = """
        CREATE OR REPLACE FUNCTION record_user_login(
            p_user_id UUID,
            p_ip_address TEXT DEFAULT NULL,
            p_user_agent TEXT DEFAULT NULL,
            p_session_id TEXT DEFAULT NULL,
            p_login_method TEXT DEFAULT 'email'
        )
        RETURNS JSON
        LANGUAGE plpgsql
        SECURITY DEFINER
        AS $$
        DECLARE
            login_record_id UUID;
            activity_record_id UUID;
        BEGIN
            INSERT INTO user_login_logs (
                user_id, 
                ip_address, 
                user_agent, 
                session_id, 
                login_method,
                success
            ) VALUES (
                p_user_id,
                CASE WHEN p_ip_address IS NOT NULL THEN p_ip_address::INET ELSE NULL END,
                p_user_agent,
                p_session_id,
                p_login_method,
                true
            ) RETURNING id INTO login_record_id;

            INSERT INTO user_activities (
                user_id,
                activity_type,
                activity_data,
                session_id,
                ip_address,
                user_agent,
                metadata
            ) VALUES (
                p_user_id,
                'login',
                jsonb_build_object(
                    'login_method', p_login_method,
                    'timestamp', NOW(),
                    'login_record_id', login_record_id
                ),
                p_session_id,
                CASE WHEN p_ip_address IS NOT NULL THEN p_ip_address::INET ELSE NULL END,
                p_user_agent,
                jsonb_build_object(
                    'source', 'login_tracker',
                    'version', '1.0'
                )
            ) RETURNING id INTO activity_record_id;

            RETURN json_build_object(
                'success', true,
                'login_record_id', login_record_id,
                'activity_record_id', activity_record_id,
                'message', 'Login recorded successfully'
            );

        EXCEPTION WHEN OTHERS THEN
            RETURN json_build_object(
                'success', false,
                'error', SQLERRM,
                'message', 'Failed to record login'
            );
        END;
        $$;
        
        GRANT EXECUTE ON FUNCTION record_user_login TO anon, authenticated, service_role;
        """
        
        # í™œë™ ê¸°ë¡ í•¨ìˆ˜
        activity_function_sql = """
        CREATE OR REPLACE FUNCTION record_user_activity(
            p_user_id UUID,
            p_activity_type TEXT,
            p_activity_data JSONB DEFAULT '{}',
            p_session_id TEXT DEFAULT NULL,
            p_ip_address TEXT DEFAULT NULL,
            p_user_agent TEXT DEFAULT NULL
        )
        RETURNS JSON
        LANGUAGE plpgsql
        SECURITY DEFINER
        AS $$
        DECLARE
            activity_id UUID;
        BEGIN
            INSERT INTO user_activities (
                user_id,
                activity_type,
                activity_data,
                session_id,
                ip_address,
                user_agent,
                metadata
            ) VALUES (
                p_user_id,
                p_activity_type,
                p_activity_data,
                p_session_id,
                CASE WHEN p_ip_address IS NOT NULL THEN p_ip_address::INET ELSE NULL END,
                p_user_agent,
                jsonb_build_object(
                    'recorded_at', NOW(),
                    'source', 'activity_tracker'
                )
            ) RETURNING id INTO activity_id;

            RETURN json_build_object(
                'success', true,
                'activity_id', activity_id,
                'message', 'Activity recorded successfully'
            );

        EXCEPTION WHEN OTHERS THEN
            RETURN json_build_object(
                'success', false,
                'error', SQLERRM,
                'message', 'Failed to record activity'
            );
        END;
        $$;
        
        GRANT EXECUTE ON FUNCTION record_user_activity TO anon, authenticated, service_role;
        """
        
        try:
            async with self.db_pool.acquire() as conn:
                await conn.execute(login_function_sql)
                logger.info("record_user_login í•¨ìˆ˜ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.")
                
                await conn.execute(activity_function_sql)
                logger.info("record_user_activity í•¨ìˆ˜ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.")
                
        except Exception as e:
            logger.error(f"RPC í•¨ìˆ˜ ìƒì„± ì¤‘ ì˜¤ë¥˜: {e}")
            raise
    
    async def test_login_recording(self) -> bool:
        """ë¡œê·¸ì¸ ê¸°ë¡ í…ŒìŠ¤íŠ¸"""
        logger.info("ë¡œê·¸ì¸ ê¸°ë¡ ê¸°ëŠ¥ì„ í…ŒìŠ¤íŠ¸í•˜ê³  ìˆìŠµë‹ˆë‹¤...")
        
        try:
            # í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì ìƒì„± (ì´ë¯¸ ì¡´ì¬í•  ìˆ˜ ìˆìŒ)
            test_email = "test_login@example.com"
            test_password = "test_password_123"
            
            # ì‚¬ìš©ì ë“±ë¡ ì‹œë„ (ì´ë¯¸ ì¡´ì¬í•˜ë©´ ë¬´ì‹œ)
            try:
                auth_response = self.supabase.auth.sign_up({
                    "email": test_email,
                    "password": test_password
                })
                if auth_response.user:
                    test_user_id = auth_response.user.id
                    logger.info(f"í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì ìƒì„±ë¨: {test_user_id}")
                else:
                    # ê¸°ì¡´ ì‚¬ìš©ì ë¡œê·¸ì¸
                    auth_response = self.supabase.auth.sign_in_with_password({
                        "email": test_email,
                        "password": test_password
                    })
                    test_user_id = auth_response.user.id
                    logger.info(f"ê¸°ì¡´ í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì ì‚¬ìš©: {test_user_id}")
            except Exception as auth_error:
                logger.warning(f"í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì ì¸ì¦ ì˜¤ë¥˜: {auth_error}")
                # ì„ì‹œ UUID ì‚¬ìš©
                test_user_id = "00000000-0000-0000-0000-000000000000"
            
            # RPC í•¨ìˆ˜ë¥¼ í†µí•œ ë¡œê·¸ì¸ ê¸°ë¡ í…ŒìŠ¤íŠ¸
            result = self.supabase.rpc('record_user_login', {
                'p_user_id': test_user_id,
                'p_ip_address': '127.0.0.1',
                'p_user_agent': 'Test User Agent',
                'p_session_id': f'test_session_{datetime.now().timestamp()}',
                'p_login_method': 'email'
            }).execute()
            
            if result.data and result.data.get('success'):
                logger.info("ë¡œê·¸ì¸ ê¸°ë¡ í…ŒìŠ¤íŠ¸ ì„±ê³µ!")
                return True
            else:
                logger.error(f"ë¡œê·¸ì¸ ê¸°ë¡ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {result.data}")
                return False
                
        except Exception as e:
            logger.error(f"ë¡œê·¸ì¸ ê¸°ë¡ í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜: {e}")
            return False
    
    async def generate_test_data(self, count: int = 10):
        """í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±"""
        logger.info(f"{count}ê°œì˜ í…ŒìŠ¤íŠ¸ ë¡œê·¸ì¸ ê¸°ë¡ì„ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...")
        
        try:
            # ê¸°ì¡´ ì‚¬ìš©ì ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            users_response = self.supabase.table('auth.users').select('id').limit(5).execute()
            
            if not users_response.data:
                logger.warning("í…ŒìŠ¤íŠ¸í•  ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.")
                return
            
            user_ids = [user['id'] for user in users_response.data]
            
            for i in range(count):
                user_id = user_ids[i % len(user_ids)]
                
                # ê³¼ê±° ì‹œê°„ ìƒì„± (ìµœê·¼ 30ì¼ ë‚´)
                days_ago = i % 30
                login_time = datetime.now() - timedelta(days=days_ago)
                
                result = self.supabase.rpc('record_user_login', {
                    'p_user_id': user_id,
                    'p_ip_address': f'192.168.1.{100 + (i % 50)}',
                    'p_user_agent': f'Test Browser {i}',
                    'p_session_id': f'test_session_{i}_{login_time.timestamp()}',
                    'p_login_method': 'email'
                }).execute()
                
                if result.data and result.data.get('success'):
                    logger.info(f"í…ŒìŠ¤íŠ¸ ë¡œê·¸ì¸ ê¸°ë¡ {i+1}/{count} ìƒì„± ì™„ë£Œ")
                else:
                    logger.warning(f"í…ŒìŠ¤íŠ¸ ë¡œê·¸ì¸ ê¸°ë¡ {i+1} ìƒì„± ì‹¤íŒ¨: {result.data}")
                    
        except Exception as e:
            logger.error(f"í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„± ì¤‘ ì˜¤ë¥˜: {e}")
    
    async def verify_fix(self) -> Dict[str, Any]:
        """ìˆ˜ì • ì‚¬í•­ ê²€ì¦"""
        logger.info("ìˆ˜ì • ì‚¬í•­ì„ ê²€ì¦í•˜ê³  ìˆìŠµë‹ˆë‹¤...")
        
        verification_results = {
            'table_structure': False,
            'rls_policies': False,
            'rpc_functions': False,
            'login_recording': False,
            'data_count': 0,
            'errors': []
        }
        
        try:
            # í…Œì´ë¸” êµ¬ì¡° í™•ì¸
            checks = await self.check_table_structure()
            verification_results['table_structure'] = all([
                checks['user_login_logs_exists'],
                checks['user_activities_exists']
            ])
            verification_results['rls_policies'] = checks['rls_policies_correct']
            verification_results['rpc_functions'] = checks['rpc_functions_exist']
            
            # ë¡œê·¸ì¸ ê¸°ë¡ í…ŒìŠ¤íŠ¸
            verification_results['login_recording'] = await self.test_login_recording()
            
            # ë°ì´í„° ê°œìˆ˜ í™•ì¸
            count_response = self.supabase.table('user_login_logs').select('id', count='exact').execute()
            verification_results['data_count'] = count_response.count or 0
            
        except Exception as e:
            verification_results['errors'].append(str(e))
            logger.error(f"ê²€ì¦ ì¤‘ ì˜¤ë¥˜: {e}")
        
        return verification_results
    
    async def run_complete_fix(self):
        """ì „ì²´ ìˆ˜ì • í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰"""
        logger.info("ë¡œê·¸ì¸ ê¸°ë¡ ìˆ˜ì • í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤...")
        
        try:
            # 1. ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
            await self.initialize_db_pool()
            
            # 2. í˜„ì¬ ìƒíƒœ í™•ì¸
            initial_checks = await self.check_table_structure()
            logger.info(f"ì´ˆê¸° ìƒíƒœ: {initial_checks}")
            
            # 3. í…Œì´ë¸” êµ¬ì¡° ìˆ˜ì •
            await self.fix_table_structure()
            
            # 4. RLS ì •ì±… ìˆ˜ì •
            await self.fix_rls_policies()
            
            # 5. RPC í•¨ìˆ˜ ìƒì„±
            await self.create_rpc_functions()
            
            # 6. í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
            await self.generate_test_data(20)
            
            # 7. ìµœì¢… ê²€ì¦
            final_verification = await self.verify_fix()
            logger.info(f"ìµœì¢… ê²€ì¦ ê²°ê³¼: {final_verification}")
            
            if all([
                final_verification['table_structure'],
                final_verification['rls_policies'],
                final_verification['rpc_functions'],
                final_verification['login_recording']
            ]):
                logger.info("âœ… ë¡œê·¸ì¸ ê¸°ë¡ ìˆ˜ì •ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
                logger.info(f"ìƒì„±ëœ ë¡œê·¸ì¸ ê¸°ë¡ ìˆ˜: {final_verification['data_count']}")
            else:
                logger.error("âŒ ì¼ë¶€ ìˆ˜ì • ì‚¬í•­ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
                logger.error(f"ì˜¤ë¥˜: {final_verification['errors']}")
            
        except Exception as e:
            logger.error(f"ìˆ˜ì • í”„ë¡œì„¸ìŠ¤ ì¤‘ ì¹˜ëª…ì  ì˜¤ë¥˜: {e}")
            raise
        finally:
            await self.close_db_pool()

def load_config() -> DatabaseConfig:
    """í™˜ê²½ ë³€ìˆ˜ì—ì„œ ì„¤ì • ë¡œë“œ"""
    required_vars = [
        'SUPABASE_URL',
        'SUPABASE_ANON_KEY', 
        'SUPABASE_SERVICE_ROLE_KEY',
        'DATABASE_URL',
        'DB_PASSWORD'
    ]
    
    missing_vars = [var for var in required_vars if not os.getenv(var)]
    if missing_vars:
        logger.error(f"í•„ìˆ˜ í™˜ê²½ ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤: {missing_vars}")
        sys.exit(1)
    
    return DatabaseConfig(
        url=os.getenv('SUPABASE_URL'),
        key=os.getenv('SUPABASE_ANON_KEY'),
        service_key=os.getenv('SUPABASE_SERVICE_ROLE_KEY'),
        db_url=os.getenv('DATABASE_URL'),
        db_password=os.getenv('DB_PASSWORD')
    )

async def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("ğŸ”§ íŠ¹í—ˆ AI í”Œë«í¼ ë¡œê·¸ì¸ ê¸°ë¡ ìˆ˜ì • ë„êµ¬")
    print("=" * 50)
    
    try:
        # ì„¤ì • ë¡œë“œ
        config = load_config()
        
        # ìˆ˜ì • ë„êµ¬ ì´ˆê¸°í™”
        fixer = LoginRecordFixer(config)
        
        # ì „ì²´ ìˆ˜ì • í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
        await fixer.run_complete_fix()
        
        print("\nâœ… ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
        print("ì´ì œ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë¡œê·¸ì¸ ê¸°ë¡ì´ ì •ìƒì ìœ¼ë¡œ ì €ì¥ë©ë‹ˆë‹¤.")
        
    except KeyboardInterrupt:
        print("\nâŒ ì‚¬ìš©ìì— ì˜í•´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
    except Exception as e:
        print(f"\nâŒ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())
```

### 2. í™˜ê²½ ì„¤ì • íŒŒì¼
```bash
# .env íŒŒì¼ ì˜ˆì‹œ
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
DATABASE_URL=postgresql://postgres:password@db.your-project.supabase.co:5432/postgres
DB_PASSWORD=your-database-password
```

### 3. ìš”êµ¬ì‚¬í•­ íŒŒì¼
```txt
# requirements.txt
supabase==2.0.0
asyncpg==0.29.0
requests==2.31.0
python-dotenv==1.0.0
```

## ì‹¤í–‰ ë°©ë²•

### 1. í™˜ê²½ ì¤€ë¹„
```bash
# ê°€ìƒí™˜ê²½ ìƒì„±
python -m venv venv

# ê°€ìƒí™˜ê²½ í™œì„±í™” (Windows)
venv\Scripts\activate

# ê°€ìƒí™˜ê²½ í™œì„±í™” (Linux/Mac)
source venv/bin/activate

# íŒ¨í‚¤ì§€ ì„¤ì¹˜
pip install -r requirements.txt
```

### 2. í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
```bash
# .env íŒŒì¼ ìƒì„± ë° ì„¤ì •
cp .env.example .env
# .env íŒŒì¼ì„ í¸ì§‘í•˜ì—¬ ì‹¤ì œ ê°’ ì…ë ¥
```

### 3. ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
```bash
# ì „ì²´ ìˆ˜ì • í”„ë¡œì„¸ìŠ¤ ì‹¤í–‰
python fix_login_recording.py

# ë¡œê·¸ í™•ì¸
tail -f login_fix.log
```

## ê²€ì¦ ë°©ë²•

### 1. ë°ì´í„°ë² ì´ìŠ¤ ì§ì ‘ í™•ì¸
```sql
-- ë¡œê·¸ì¸ ê¸°ë¡ í™•ì¸
SELECT COUNT(*) FROM user_login_logs;
SELECT * FROM user_login_logs ORDER BY login_time DESC LIMIT 10;

-- í™œë™ ê¸°ë¡ í™•ì¸
SELECT COUNT(*) FROM user_activities WHERE activity_type = 'login';
SELECT * FROM user_activities WHERE activity_type = 'login' ORDER BY created_at DESC LIMIT 10;

-- RPC í•¨ìˆ˜ í…ŒìŠ¤íŠ¸
SELECT record_user_login(
    'test-user-id'::UUID,
    '127.0.0.1',
    'Test User Agent',
    'test-session-123',
    'email'
);
```

### 2. ì• í”Œë¦¬ì¼€ì´ì…˜ í…ŒìŠ¤íŠ¸
```javascript
// í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ë¡œê·¸ì¸ í›„ í™•ì¸
console.log('ë¡œê·¸ì¸ ì„±ê³µ í›„ ActivityTracker í˜¸ì¶œ');

// ëŒ€ì‹œë³´ë“œì—ì„œ í†µê³„ í™•ì¸
const stats = await getDashboardStats();
console.log('ë¡œê·¸ì¸ í†µê³„:', stats.dashboardStatistics.total_logins);
```

## ë¬¸ì œ í•´ê²°

### 1. ê¶Œí•œ ì˜¤ë¥˜
```sql
-- ê¶Œí•œ ì¬ì„¤ì •
GRANT ALL PRIVILEGES ON user_login_logs TO authenticated;
GRANT ALL PRIVILEGES ON user_activities TO authenticated;
GRANT EXECUTE ON FUNCTION record_user_login TO anon, authenticated;
```

### 2. RLS ì •ì±… ì˜¤ë¥˜
```sql
-- RLS ì •ì±… ì¬ìƒì„±
DROP POLICY IF EXISTS "Enable insert for anon role" ON user_login_logs;
CREATE POLICY "Enable insert for anon role" ON user_login_logs
    FOR INSERT WITH CHECK (true);
```

### 3. ì—°ê²° ì˜¤ë¥˜
```python
# ì—°ê²° ì„¤ì • í™•ì¸
import os
print("SUPABASE_URL:", os.getenv('SUPABASE_URL'))
print("DATABASE_URL:", os.getenv('DATABASE_URL'))
```

ì´ ê°€ì´ë“œë¥¼ ë”°ë¼ ì‹¤í–‰í•˜ë©´ ë¡œê·¸ì¸ ê¸°ë¡ ë¬¸ì œê°€ ì™„ì „íˆ í•´ê²°ë©ë‹ˆë‹¤.